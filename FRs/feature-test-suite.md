# Worker Service Feature Request

## FEATURE NAME:

Order Integration Test Suite with Simulated Load

---

## FEATURE PURPOSE:

To implement a comprehensive integration test suite for the order processing pipeline. This suite will use Testcontainers to create an isolated, ephemeral environment (PostgreSQL, RabbitMQ, OTLP Collector), and leverage the MassTransit Test Harness to validate message flows. An order simulator will generate random orders to mimic real-world load, allowing for the validation of end-to-end functionality, reliability, and observability.

---

## CORE FUNCTIONALITY:

- **Test Environment Orchestration**: Use Testcontainers to programmatically start and stop PostgreSQL, RabbitMQ, and a Jaeger/OTLP collector for a fully isolated test run.
- **End-to-End Message Testing**: Utilize the MassTransit Test Harness to send commands, consume events, and assert that messages are processed correctly by the consumers.
- **Simulated Order Generation**: Implement a test-specific `IHostedService` (Order Simulator) that runs alongside the worker to generate and publish random `CreateOrderCommand` messages.
- **Database State Validation**: Query the test database instance to verify that order data is correctly persisted and state transitions are accurately reflected.
- **Telemetry Validation**: Configure the test environment to export OpenTelemetry data to the Jaeger container and provide guidance on how to inspect traces and metrics generated during the test run.

---

## TEST PROJECT STRUCTURE:

### `tests/WorkerService.IntegrationTests`
- **Dependencies**:
  - `Testcontainers.PostgreSql`, `Testcontainers.RabbitMq`, `Testcontainers.Otlp`
  - `MassTransit.TestFramework`
  - `Microsoft.AspNetCore.Mvc.Testing`
- **Test Fixture (`WorkerServiceTestFixture.cs`)**:
  - A shared class implementing `IAsyncLifetime` to manage the lifecycle of the Testcontainers.
  - Starts all containers before tests run (`InitializeAsync`) and stops them after (`DisposeAsync`).
  - Provides container connection strings and endpoints to the test host.
- **Custom WebApplicationFactory (`TestWebApplicationFactory.cs`)**:
  - Inherits from `WebApplicationFactory<Program>`.
  - Overrides `ConfigureWebHost` to replace production configuration (connection strings, hostnames) with the dynamic values from the Testcontainers.
  - Registers the `OrderSimulatorService` as a hosted service.
- **Order Simulator (`OrderSimulatorService.cs`)**:
  - An `IHostedService` that periodically uses `IMediator` to send `CreateOrderCommand` with randomized data.
- **Integration Tests (`OrderProcessingIntegrationTests.cs`)**:
  - The main test class that uses the fixture and factory.
  - Contains tests that run the simulator for a period and then make assertions.

---

## MESSAGING PATTERNS (FOR TESTING):

### Test Harness Usage
- The `MassTransit.TestFramework.TestHarness` will be the core component for message-related assertions.
- **Assertions**:
  - `await harness.Consumed.Any<OrderCreatedEvent>()`: Verify that specific events were consumed.
  - `await harness.Published.Any<OrderCreatedEvent>()`: Verify that events were published on the bus.
  - `await harness.Sent.Any<CreateOrderCommand>()`: Verify commands were sent.
- The test will connect the harness to the RabbitMQ Testcontainer instance.

### Simulated Messages
- **`OrderSimulatorService`**:
  - Will use `Faker` or a similar library to generate realistic but random order data.
  - Will publish `CreateOrderCommand` messages via `IMediator` at a configurable interval (e.g., every 500ms).

---

## DATABASE DESIGN (FOR TESTING):

### Testcontainers for PostgreSQL
- A `PostgreSqlContainer` will be used to spin up a dedicated PostgreSQL instance.
- The database will be ephemeral, with its schema created from scratch for each test run using `DbContext.Database.MigrateAsync()`.
- The connection string will be dynamically generated by the container and injected into the application's `IConfiguration`.

---

## OBSERVABILITY REQUIREMENTS:

### Distributed Tracing with Jaeger
- An OTLP/Jaeger Testcontainer will be started to collect telemetry.
- The test application's OpenTelemetry configuration will be updated to export traces to the OTLP endpoint provided by the container.
- **Validation**: The PRP will include instructions for developers to access the Jaeger UI via its mapped port to visually inspect the traces of the simulated orders, ensuring all spans (worker, consumer, database) are correctly correlated.

### Metrics Collection
- Metrics generated by the worker (including MassTransit and EF Core instrumentation) will also be sent to the OTLP collector.
- **Validation**: While direct assertion is complex, the goal is to confirm that metrics are being produced and can be visualized in a compatible tool (like a Prometheus container, if added).

---

## CONFIGURATION REQUIREMENTS:

### `appsettings.Testing.json` (or equivalent in-memory configuration)
- The `TestWebApplicationFactory` will override production settings:
  - `ConnectionStrings:DefaultConnection`: Set to the PostgreSQL container's connection string.
  - `MassTransit:RabbitMq:Host`: Set to the RabbitMQ container's hostname/IP.
  - `Otlp:Endpoint`: Set to the OTLP container's endpoint URL.
- All credentials will be sourced dynamically from the Testcontainers.

### Testcontainer Configuration
- **PostgreSQL**: Standard image, with a database name, user, and password.
- **RabbitMQ**: Standard `rabbitmq:3-management` image to allow UI inspection if needed.
- **Jaeger/OTLP**: Use a standard Jaeger or OTel collector image. All necessary ports (e.g., 4317 for OTLP, 16686 for Jaeger UI) will be mapped to host ports.

---

## TESTING REQUIREMENTS:

### Test Workflow
1.  **Setup**: The xUnit test fixture (`WorkerServiceTestFixture`) starts all required Testcontainers.
2.  **Arrange**: The test method creates a `TestWebApplicationFactory`, which configures the worker to use the containers and adds the `OrderSimulatorService`. The MassTransit Test Harness is started.
3.  **Act**: The test allows the `OrderSimulatorService` to run for a fixed duration (e.g., 15 seconds) to generate and process orders.
4.  **Assert**:
    - Use the MassTransit Test Harness to assert that a certain number of `OrderCreatedEvent` messages were consumed.
    - Create a scope to get an `ApplicationDbContext` instance and query the test database directly to verify that the `Orders` table contains the expected number of records with the correct final status.
    - (Manual) Check the Jaeger UI for complete, correlated traces.
5.  **Teardown**: The test fixture stops and disposes of all Testcontainers, ensuring a clean state for the next run.

---

## DEPLOYMENT CONSIDERATIONS:

### CI/CD Integration
- The integration test project should be configured to run as part of the automated build pipeline.
- The pipeline agent must have Docker installed and running to support Testcontainers.
- Tests should be runnable via the `dotnet test` command.

---

## SUCCESS CRITERIA:

- [ ] A new `WorkerService.IntegrationTests` project is created with all specified dependencies.
- [ ] A test fixture successfully manages the lifecycle of PostgreSQL, RabbitMQ, and Jaeger Testcontainers.
- [ ] The `TestWebApplicationFactory` correctly injects container configurations and registers the `OrderSimulatorService`.
- [ ] The integration test runs, and the simulator successfully publishes `CreateOrderCommand` messages.
- [ ] The MassTransit Test Harness confirms that order-related events are consumed by the worker.
- [ ] Direct database queries confirm that orders are persisted correctly in the test PostgreSQL instance.
- [ ] Traces for the simulated order workflows are visible and correctly correlated in the Jaeger UI.
- [ ] All container resources are automatically cleaned up after the test run completes.

---

## EXPECTED COMPLEXITY LEVEL:

- [X] **Intermediate** - Requires knowledge of Testcontainers, MassTransit Test Harness, and custom `WebApplicationFactory` configuration.
- [ ] **Advanced** - Complex scenarios with advanced patterns
- [ ] **Enterprise**- Full enterprise patterns with advanced monitoring and scaling

**Reasoning:** This task involves orchestrating multiple external services, customizing the application host for testing, and validating behavior across different architectural layers (messaging, database, observability). It builds upon production patterns to ensure robust, real-world validation.
